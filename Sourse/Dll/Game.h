#include "Checkers.h" // Блок глобальных объявлений
extern CBuffer Buffer; // Подключение глобальной переменной "Буфер обмена"

class Game
{
	bool AutoWhite, AutoBlack;
	int NKill, CNTMvs, ChMCount, CDepth, GWht, GCnt;  // Номер пустой клетки за фигурой противника, Кол-тво произведенных ходов, Кол-во перемещений хода, Текущая глубина просмотра, Глобальный вес хода, Кол-во ходов в ветке дерева
	bool bWeight; 
	char TMPField[8][8], Field[8][8], DefaultPos[8][8]; // Принадлежность рубящего хода, Положение на доске, 
	 bool Rotate, Master; // Белые-компьтер, Черные-компьютер, Положение поля, Чей ход
	 int MaxDepth; CBuffer *Buf; // Максимальная глубина просмотра, массив буферов(копии поля игры для рекурсивного просмотра в глубину)

	// ------------- ******************* ------------- ************* ----------------

	// ----------- Смещение координаты фигуры ---------------------------------------
	Point RePoint(Point& Pt, bool b, int n) // Pt - текущая координата, b - Горизонтальный коэффициент (лево/право; true - лево), n - количество клеток
		{if(b) Pt << n; else Pt >> n; return Pt;}; // Смещаем координату по указанному направлению на указанное кол-во клеток 

	// ----------- Получение списка возможных ходов -----------------------
	 void GMList() // Получение списка возможных ходов в рабочей копии поля
	{ 
		Point Pt; // Создаем переменную - координата.
		for(int j = 0; j < 8; j++) for(int i = 0; i < 8; i++) // Циклы обхода поля
		{			
			char Fg = GFigure(Pt.Set(i, j)); if(fFigure(Fg) && (fFColor(Fg) == Buf[CDepth].Master)) // Если в текущих координатах фигура Fg, и ее цвет - цвет игрока на текущей глубине - тогда:
			{Move Mov(Pt); pSField(TMPField, Buf[CDepth].Field); CheckMoves(Mov, true);} // Создаем ход с текущей начальной координатой, заполняем копию поля игры и проверяем возможные ходы, начиная с текущего, с записью хода в буфер текущей глубины. 
		} // - for		
	}; // - GMList

	// -------- Взвешивание позиции на поле после хода -------------------
	 void Weighting(Move& Mv) // Взвешивание позиции на поле после хода Mv
	{	
		GCnt++; // Увеличиваем количество ходов в ветке дерева
		pSField(TMPField, Buf[CDepth].Field); int Wht, Cnt; Moves M; Point Pt, APt; ExecMove(Mv); // Загружаем в рабочую копию поле текущего уровня
		CDepth++; Buf[CDepth].Set(TMPField, Buf[CDepth - 1].Master); Buf[CDepth].Mvs.Clear(); // Увеличиваем уровень глубины, копируем на текущий уровень поле и текущего игрока, очищаем список ходов текущего уровня
		for(int j = 0; j < 8; j++) for(int i = 0; i < 8; i++) // Циклы обхода поля
		{			
			char Fg = GFigure(Pt.Set(i, j)); if(!fFigure(Fg)) continue; // получаем текущее значение поля для текущей координаты Pt. Если это не фигура - продолжить цикл
			Move Mov(Pt); bWeight = (fFColor(Fg) == Buf[CDepth].Master); Cnt = CheckMoves(Mov, true); // Создаем новый ход от Pt. Устанавливаем принадлежность рубящего хода, получаем динамический вес вожможных ходов из нового положения
			pSField(TMPField, Buf[CDepth].Field); Wht = FWeight(Pt) + 1 * Cnt + 1 * ((Pt.X < 2) || (Pt.X > 5)); // Загружаем в рабочую копию поле текущего уровня, получаем окончательный вес позиции (из статического, динамического весов, и коэффициент для уравновешивания боковых линий с центром поля)
			if(fFColor(Fg) == Master) GWht += Wht; else GWht -= Wht; // Увеличиваем или уменьшаем глобальный вес хода, в зависимости от принадлежности хода.
		} // - for
		CDepth--; // Возвращаем текущий уровень глубины
	}; // - Weighting	

	// ----------- Заполнение и сортировка списка возможных ходов ----------------------
	 void SortMList(int Dp = 0) // Заполнение и сортировка списка возможных ходов с текущей глубиной Dp (рекурсивная)
	{
		CDepth = Dp; Move Mv; // Сохраняем текущую глубину просмотра (для рекурсии), Создаем пустую переменную типа - Ход
		if(!CDepth) Buf[CDepth].Set(Field, Master); // Если уровень верхний - устанавливаем значения его буфера из поля игры 
		Buf[CDepth].Mvs.Clear(); GMList(); //Очищаем список ходов на текущей глубине и получаем список возможных ходов
		if((!Buf[CDepth].Mvs.Count()) || ((CDepth == 1) && (!ReMaster(false)))) return; // Возврат из процедуры, если в списке текущей глубины нет ни одного хода, или... (не помню, зачем...)
		Buf[CDepth].Mvs.ToStart(); // Получаем первый ход из списка текущей глубины
		while(Buf[CDepth].Mvs.Next(Mv)) // Пока существует следующий ход в списке - Цикл 
		{
			if(!CDepth) {GWht = 0; GCnt = 0;} // Если текущий уровень верхний, обнуляем - глобальный вес хода и кол-во ходов в ветке дерева
			if(Buf[CDepth].Mvs.Kills != Mv.Kill){Buf[CDepth].Mvs.Delete(); continue;} // Если в списке есть рубящие ходы, а текущий не рубящий - удаляем его из списка и переходим на следующую итерацию цикла
			pSField(TMPField, Buf[CDepth].Field); ExecMove(Mv); // Заполняем рабочую копию поля из буфера текущей глубины и выполняем текущий ход без обновления поля. 
			Buf[CDepth + 1].Set(TMPField, !Buf[CDepth].Master); // Заполняем буфер следующего уровня текущим положением и цветом игрока, противоположным текущему
			if(CDepth == MaxDepth) Weighting(Mv); // Если текущая глубина - максимальная, взвешиваем позицию по текущему ходу Mv
			else  // Иначе:
			{
				CDepth++; SortMList(CDepth); CDepth--; // Увеличиваем глубину просмотра, заполняем и сортируем список ходов на новой глубине (рекурсия) и возвращаем текущую глубину.
				if(!Buf[CDepth + 1].Mvs.Count()) GWht += 100000 * ((Buf[CDepth].Master == Master) ? 1 : -1); // Если на следующем уровне глубины количество ходов противника == 0, добавляем глобальному весу хода 100000 (если нет ходов у противника) или -100000, если у текущего игрока
			} // - else
			if(!CDepth) {Mv.Weight = (GWht * 10000) / (GCnt + 1); // Если текущий уровень верхний - устанавливаем вес хода (увеличенный глобальный вес / кол-во ходов плюс 1(во избежание деления на 0)) 
			Mv.OppCount = Buf[CDepth + 1].Mvs.Count(); Buf[CDepth].Mvs.Set(Mv);} // Количество ходов противника = количество ходов на следующем уровне, в список ходов текущего уровня добавляем текущий ход
		} // - while																		
		if(!CDepth) for(int i = 1; i <= Buf[CDepth].Mvs.Count(); i++) Buf[CDepth].Mvs.Sorted(i); // Если текущий уровень верхний - сортируем список ходов по убыванию веса хода
			//if((!CDepth) && (ReMaster(false))) PrintMoves(Buf[0].Mvs, MaxDepth); /////////***** Печать списка ходов верхенго уровня и текущей глубины (для отладки) *****
	}; // - SortMList

	// --------- Получить статический вес фигуры -------------------------
	  int FWeight(const Point& Pt) // Получить статический вес фигуры с координатой pt
	{
		char Fg = abs(GFigure(Pt)); if(Fg < 2) return 0; // Получаем значение клетки доски. Если клетка пуста - возврат: 0
		if (Fg > 8) return Fg + 3 * (Pt.X == Pt.Y); // Дамка = значение фигуры + 3 за центральную линию
		else return Fg + fRotating(Pt.Y, fFColor(GFigure(Pt))) / 2; // Пешка = значение фигуры + растояние от начальной линии / 2
	}; // - FWeight

	// ----------- Выполнение текущего хода --------------------------------
	 void ExecMove(Move& Mov, bool Rec = false) // Выполнение текущего хода Mov с признаком записи в основное поле игры Rec
	{
		Point SPt, FPt; Mov.Pts.First(SPt);	Mov.Pts.Last(FPt); // Создаем переменные для стартовой и конечной координат. Заполняем их.
		char Fg = GFigure(SPt);	SFigure(SPt, GFigure(FPt)); SFigure(FPt, Fg); // Меняем местами фигуры на стартовой и конечной позиции.
		if(FPt.Y == 7 * !fFColor(Fg)) SFigure(FPt, 9 * (2 * !fFColor(Fg)) - 9); // Если пешка попала на крайнюю линию противника - преобразовываем ее в дамку.
		if(Mov.Kill) // Если ход рубящий, тогда:
		{
			Mov.Pts.ToStart(); for(int i = 0; Mov.Pts.Next(SPt); i++) // Устанавливаем указатель на первую координату хода и обходим в цикле все координаты хода
			if(i % 2) SFigure(SPt, 1); // На каждой четной координате, очищаем черную клетку поля (срубленные фигуры противника)
			else if(SPt.Y == 7 * !fFColor(Fg)) SFigure(FPt, 9 * (2 * !fFColor(Fg)) - 9); // Если пешка попала на крайнюю линию противника - преобразовываем ее в дамку.
		} // - if
		if(Rec){pSField(Field, TMPField); Master = !Master; ReMaster(false); CNTMvs++;} // Если обновлять поле - Обновляем поле из рабочей копии, меняем текущего игрока, вычисляем владельца хода и положения доски на текущий момент, увеличиваем количество произведенных ходов
	}; // - ExecMove

	// ----------- Установить на поле фигуру ------------------------------
	 void SFigure(const Point& Pt, char Fg) // Установить на поле фигуру Fg по адресу Pt
	{   // (на рабочей копии поля)
		if((Pt.X >= 0) && (Pt.X <= 7) && (Pt.Y >= 0) && (Pt.Y <= 7)) TMPField[Pt.Y][Pt.X] = Fg; // Если координата в пределах доски - устанавливаем новое значение клетки
	}; // - SFigure

	// ------- Проверить возможность хода по направлению -------------------
	Point CheckVector(const Point& Pt, const int Vec)  // Проверить возможность хода по направлению Vec из точки Pt
	{
		Point Res, TPt(Pt); int Bef = 0, Afft = 0, kfSCol = (Vec < 3) ? 1 : -1; // Создаем переменную результата, копируес стартовую координату, создаем значения количества пустых клеток до преграды и после нее, определяем коэффициент цвета фигуры
 		while(GFigure(RePoint(TPt, Vec % 2, kfSCol)) == 1) Bef++; // Пока следующая клекта по направлению пуста - увеличиваем значение количества пустых клеток до преграды
		if(fFColor(GFigure(TPt)) != fFColor(GFigure(Pt))) // Если преграда - фигура противника - тогда:
		while(GFigure(RePoint(TPt, Vec % 2, kfSCol)) == 1) Afft++; // Пока следующая клекта по направлению пуста - увеличиваем значение количества пустых клеток после преграды
		return Res.Set(Bef, Afft); // Возврат - количество пустых клеток до преграды и после нее
	}; // - CheckVector

	// ----------- Заполнить список координат перемещений ---------------------------
	  int CheckMoves(Move Mov, bool Rec, int rVec = 0) // Заполнить список координат перемещений в пределах хода Mov с признаком записи Rec и запретным направлением rVec (рекурсивная)
	{
		char CFld[8][8]; Point FPt; Mov.Pts.Last(FPt); // Создаем контекст копию поля (для рекурсии), конечная координата хода (она же начальная из списка, т.к. в списке только стартовая координата)
		pSField(CFld, TMPField); char Fg = GFigure(FPt); // Сохраняем рабочую копию поля, получаем значение фигуры в стартовой точке
		if(!rVec) ChMCount = 0;  int Re = NKill; // Если не указано запретное направление (первый раз в функции) - обнуляем кол-во перемещений хода, запомним номер пустой клетки за срубленной фигурой противника (для рекурсии)
		bool KKing = abs(Fg) > 8, KColor = fFColor(Fg); // Установим Флаги дамки и цвета фигуры
		for(int Vec = 1; Vec <= 4; Vec++) // Обходим в цикле четыре возможных направления
		{	
			int kfSCol = (Vec < 3) ? 1 : -1; pSField(TMPField, CFld); // kfSCol - вертикальный коэффициент (верх/низ; 1 - верх), обновляем копию поля
			Point Pres = CheckVector(FPt, Vec); // Проверка возвожности перемещения по текущему направлению Vec с точки FPt; Возврат: Pres - Первая цифра - кол-во пустых клеток до первого препятствия, вторая - до второго, если первое - одна фигура противника
			if(!rVec && (Pres.X > 0) && (Pres.Y <= !KKing * 10)) // Если направление не запретно, есть пространство до первой преграды и нет пространства после для дамки - тогда:
			{
				if(!KKing && (KColor != (Vec > 2))) continue; // Если не дамка и направление к начальной линии, продолжить цикл
				Point TmpPt(FPt); ChMCount++; if(!Rec) continue;  // Новая координата - копия старой, увеличиваем кол-во перемещений хода, если без записи - продолжить цикл
				for(int j = 1; j <= (Pres.X * KKing) + (1 * !KKing); j++) // Цикл по количеству пустых клеток до первого препятствия (для пешки всегда == 1)
				{
					RePoint(TmpPt, Vec % 2, kfSCol); Move TmpMov = Mov; // Смещаем координату TmpPt в указанном направлении, создаем новый ход - копию входящего
					TmpMov.Pts.Add(TmpPt); Buf[CDepth].Mvs.Add(TmpMov); // Добавляем к копии хода новую конечную координату. Добавляем в буфер текущего уровня ход в список
				} // - for
			} // - if
			if((Vec != 5 - rVec) && (Pres.X <= KKing * 10) && (Pres.Y > 0)) // Если направление не обратно запретному, для пешки нет свободных клеток перед первым препятствием, и есть пустые клетки после него - тогда:
			{	
				if(!Rec) {ChMCount++; continue;} // Увеличиваем кол-во перемещений хода, если проверка без записи - продолжить цикл
				if((Vec == rVec) && (Re > 1)) continue; // Если направление запретно (в нем уже рубили) и мы рассматриваем > 1 пустую клетку за фигурой противника - продолжить цикл
				Point KilPt(FPt), TmpPt; RePoint(KilPt, Vec % 2, (Pres.X + 1) * kfSCol); // Координата рубимой фигуры, устанавливаем ее на фигуру противника
				Move TKMov = Mov, TmpMov; TKMov.Kill = Buf[CDepth].Mvs.Kills = true; TKMov.Pts.Add(KilPt); // Создаем рубящий ход, добавляем в него координату рубимой фигуры, устанавливаем флаги рубки на ход и список ходов текущего уровня
				int TmpCount = Buf[CDepth].Mvs.Count(), SUp = (Pres.Y * KKing) + (1 * !KKing); // Сохраняем количество ходов в списке (для рекурсии), определяем количетсво возможных конечных координат хода (1 для пешки и Pres.Y для дамки)
				for(int j = 1; j <= SUp; j++) // Цикл от 1 до количетсва возможных конечных координат хода
				{
					if(j == 1) ChMCount += 2 + (KKing) * 2 + (!bWeight) * FWeight(KilPt); // Для первой координаты после рубимой фигуры определяем динамический вес хода (от рубимой фигуры, ее цвета, и веса)
					TmpPt = FPt; TmpMov = TKMov; RePoint(TmpPt, Vec % 2, (j + Pres.X + 1) * kfSCol); // Создаем ход и новую конечную координату, которую смещаем на возможные позиции за рубимой фигурой
					TmpMov.Pts.Add(TmpPt); pSField(TMPField, Buf[CDepth].Field); ExecMove(TmpMov); // Добавляем в ход полученную координату, обновляем рабочую копию поля из буфера текущего уровня и исполняем ход без записи в основное поле игры 
					NKill = j; CheckMoves(TmpMov, true, Vec); // Установим номер пустой клетки за срубленной фигурой противника, заполним список координат перемещений из новой позиции с указанием запретного направления (рекурсия)
				} // - for
				
				pSField(TMPField, CFld); if(TmpCount == Buf[CDepth].Mvs.Count()) // Обновляем копию поля из сохраненного контекста, если список ходов не пополнился (нет возможности проболжать циклическую рубку) - тогда:
				{
					for(int j = 1; j <= SUp; j++) // Повтор цикла от 1 до количетсва возможных конечных координат хода
					{
						TmpPt = FPt; RePoint(TmpPt, Vec % 2, (j + Pres.X + 1) * kfSCol); // Создаем и сохраняем все возможные конечные координаты в ходы
						TmpMov = TKMov; TmpMov.Pts.Add(TmpPt); Buf[CDepth].Mvs.Add(TmpMov); // Добавляем новые ходы в список ходов текущего уровня
					} // - for
				} // - if
			} // - if
		} // - for
		return ChMCount; // Возврат - количество возможных ходов (их динамический вес)
	}; // - CheckMoves

public:
	// ----------- конструктор -----------------------------------------
	Game() // Конструктор
		{New(); MaxDepth = lmedium; Buf = new CBuffer[MaxDepth + 2];
		bWeight = false;}; // Стартовая глубина и стартовый массив буферов губины просмотра	 // -------- Установка начальных значений игры ----------------------

	// ----------- Получить на поле фигуру -------------------------------
	 char GFigure(const Point& Pt) // Получить на поле фигуру с координатой Pt
	{
		if((Pt.X < 0) || (Pt.Y < 0) || (Pt.X > 7) || (Pt.Y > 7)) return 0; // Если координата за пределами доски - возврат - 0
		return TMPField[Pt.Y][Pt.X]; // Иначе - значение клетки доски (на рабочей копии поля)
	}; // - GFigure

	// -------- Установка начальных значений игры ----------------------
	 void New() // Установка начальных значений игры (поле, чей ход и т.п.)
	 {
		char dp[8][8]= {
		{2, 0, 2, 0, 2, 0, 2, 0},
		{0, 2, 0, 2, 0, 2, 0, 2},
		{2, 0, 2, 0, 2, 0, 2, 0},
		{0, 1, 0, 1, 0, 1, 0, 1},
		{1, 0, 1, 0, 1, 0, 1, 0},
		{0,-2, 0,-2, 0,-2, 0,-2},
		{-2, 0,-2, 0,-2, 0,-2, 0},
		{0,-2, 0,-2, 0,-2, 0,-2}}; // Массив со стартовыми значениями фигур на поле игры.
		Rotate = Master = colWhite; AutoWhite = false; AutoBlack = true; //Разворот доски и текущий ход белых. Компьютер играет черными
		pSField(Field, dp); Buffer.Set(dp, Master); // Начальная позиция на доске и заполнение буфера обмена.
	 }; // - New

	// ----------- Расчет хода компьютера ---------------------------------
	  int AutoMove() // Расчет хода компьютера
	{
		Move Mov; pSField(TMPField, Field); SortMList(); //Создаем ход с пустым списком перемещений. Заполняем рабочую копию поля игры. Заполнение и сортировка списка возможных ходов.
		if(!Buf[0].Mvs.First(Mov)) return reGameOver; // Если на верхнем уровне дерева ходов список пуст (отсутствует первый элемент) - возврат "Конец игры". Ход сохраняется в переменной Mov
		pSField(TMPField, Field); ExecMove(Mov, true); // Обновляем копию хода (для выполнения), выполняем ход Mov (с обновлением поля игры).
		Buffer.Mvs.Clear(); Buffer.Set(Field, Master); Buffer.Add(Mov); // Очищаем список ходов буфера обмена. Записываем в буфер обмена текущее состояние поля игры, текущего игрока, в список - Первый ход Mov
		if((AutoWhite == AutoBlack) && (CNTMvs > 300)) return reDrawGame; // Если игра "сам с собой" и количество произведенных ходов > 300, возврат - "ничья"
		if(!Mov.OppCount) return reGameOver; return reOk; // Конец игры, если противнику некуда ходить. Иначе - возврат "Ход". 
	}; // - AutoMove

	// ---- Установка максимальной глубины просчета --------------------
	 void SBuf(int MD) // Установка максимальной глубины просчета и массива буферов в зависимисти от уровня игры MD
	 {
		delete[] Buf; // Очистка существующего массива буферов губины просмотра
		MaxDepth = MD; // Установка глубины
		Buf = new CBuffer[MaxDepth + 2]; // Создание массива буферов губины просмотра (+ 2 контрольных)
	 }; // - SBuf

	// -- Вычисления владельца хода и положения доски на текущий момент ---
	 bool ReMaster(bool New) // Вычисления владельца хода и положения доски на текущий момент с возможностью установки начальных згачений (признак New)
	 {
		Rotate = colWhite; if(New) Master = colWhite; // Разворачиваем доску под белых. Если новая игра - ход белых
		if(!AutoWhite && !AutoBlack) Rotate = Master; // Если компьютер не играет обоими цветами - развернуть доску под цвет текущего игрока
		else if(AutoWhite && !AutoBlack) Rotate = colBlack; // Иначе, если Компьютер играет белыми - развернуть доску под черных
		return ((Master && AutoBlack) || (!Master && AutoWhite)); // Истина - если текущий ход компьютера. 
	 }; // - ReMaster

	// ----------- Установить цвет фигур компьютера --------------------
	 void SMaster(bool AW, bool AB) // Установить цвет фигур компьютера
		{AutoWhite = AW; AutoBlack = AB;}; // AW и AB - цвета игры компьютера

	// ----------- Получить текущее положение поля игры --------------------
	 bool GRotate(){return Rotate;}; // Получить текущее положение поля игры

	// ----------- Получить текущго хозяина хода --------------------
	 bool GMaster(){return Master;}; // Получить текущго хозяина хода

	// ----------- Обработка хода пользователя ---------------------------
	  int ManualMove(const Point* SFPt) // Обработка хода пользователя
	{	
		Move Mov(SFPt[0]); bool GOver = false; // Создаем ход со стартовой координатой и переменную - конец игры == ложь
		Point SPt, FPt; Moves MSKill, MSBed, MSOK; // Две координаты (стартовая и конечная), три Списка ходов (Рубящие, Возможных при ошибке, Законченные)
		pSField(TMPField, Field); char Fg = GFigure(SFPt[0]); // Заполняем рабочую копию поля игры и получаем фигуру на стартовой позиции
		
		//if(!fFigure(Fg)) return reNot; // Если нет фигуры - возврат "Пустая клетка"
		//if(fFColor(Fg) != Master) return reAlien; // Если фигура противника - возврат "Фигура противника"
		//if(!CheckMoves(Mov, false)) return reBlock; // Если Фигуре некуда ходить (проверка без записи) - возврат "Некуда ходить"
		pSField(TMPField, Field); // Обновляем рабочую копию поля игры (после проверки)
		SortMList(); if(!Buf[0].Mvs.ToStart()) return reGameOver; // Заполнение и сортировка списка возможных ходов. Если на верхнем уровне дерева ходов список пуст (отсутствует первый элемент) - возврат "Конец игры"
									// Список спозиционирован на первый элемент
		while(Buf[0].Mvs.Next(Mov)) // Пока на верхнем уровне дерева ходов существует следующие элемент списка - цикл  
		{
			MSKill.Add(Mov); if(Mov.Pts.First(SPt), SPt == SFPt[0]) // Добавляем ход в список рубящих ходов. Пллучаем его стартовую координату, если она совпадает с заданой, тогда:
			{
				MSBed.Add(Mov);	if(Mov.Pts.Last(FPt), FPt == SFPt[1]) // Добавляем ход в список возможных при ошибке ходов. Пллучаем его конечную координату, если она совпадает с заданой, тогда:
				{
					pSField(TMPField, Field); ExecMove(Mov, true); // Обновляем копию хода (для выполнения), выполняем ход Mov (с обновлением поля игры). 
					MSOK.Add(Mov); GOver = (!Mov.OppCount); break; // Добавляем ход в список законченных ходов. Конец игры, если противнику некуда ходить, прерываем цикл...
				} // - if 
			} // - if
		} // - while
		Buffer.Mvs.Clear(); // Очищаем список ходов буфера обмена
		if(MSOK.Count()){Buffer.Set(Field, Master); Buffer.Addl(MSOK); return (GOver) ? reGameOver : reOk;} // Если список законченных ходов не пуст - Записываем в буфер обмена текущее состояние поля игры, текущего игрока, список законченных ходов. Если конец игры - возврат "конец игры", иначе - "Ход"
		if(MSBed.Count()){Buffer.Set(Field, Master); Buffer.Addl(MSBed); return (Buf[0].Mvs.Kills) ? reKill : reBed;} // Если список возможных при ошибке ходов не пуст - Записываем в буфер обмена текущее состояние поля игры, текущего игрока, список возможных при ошибке ходов. Если есть рубящие ходы - возврат "должны рубить", иначе - "невозможный ход"
		Buffer.Set(Field, Master); Buffer.Addl(MSKill); return (GFigure(SFPt[1]) == 1) ? reKill : reBed; //Записываем в буфер обмена текущее состояние поля игры, текущего игрока, список рубящих ходов. Если конечная точка пустая черная клетка - возврат "должны рубить", иначе - "невозможный ход"
	}; // - ManualMove

	// ----------- Установка поля игры ---------------------------
	  void SField(char (*DF)[8])  {pSField(Field, DF);};
};
// --------------------------------------